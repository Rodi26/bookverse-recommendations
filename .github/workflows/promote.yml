name: Promote

on:
  workflow_dispatch:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: choice
        default: 'PROD'
        options:
          - DEV
          - QA
          - STAGING
          - PROD
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string
  workflow_call:
    inputs:
      target_stage:
        description: 'Target stage (DEV, QA, STAGING, PROD)'
        required: true
        type: string
      application_version:
        description: 'Application version (SemVer) to promote (leave empty for latest)'
        required: false
        type: string

jobs:
  promote:
    name: Promote
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Prereqs (jq)"
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: "[Auth] Exchange GitHub OIDC for JFrog access token"
        run: |
          set -euo pipefail
          BASE="${{ vars.JFROG_URL }}"; BASE="${BASE%/}"
          if [[ -z "$BASE" ]]; then echo "Missing vars.JFROG_URL" >&2; exit 1; fi
          PROVIDER_NAME="bookverse-recommendations-github"
          # Mint GitHub OIDC ID token with audience = JFrog URL (align with CI workflow)
          JF_URL="$BASE"
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "‚ùå Missing GitHub OIDC request env vars" >&2; exit 1; fi
          echo "üîë Minting GitHub OIDC ID token (audience=$JF_URL)"
          ID_TOKEN=$(curl -fsSL -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$ID_TOKEN" || "$ID_TOKEN" == "null" ]]; then echo "‚ùå Failed to fetch GitHub ID token" >&2; exit 1; fi
          echo "üîÅ Exchanging OIDC for JFrog access token (provider=$PROVIDER_NAME)"
          PAYLOAD=$(jq -n --arg jwt "$ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "${{ vars.PROJECT_KEY }}" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          RESP=$(curl -fsSL -X POST "$JF_URL/access/api/v1/oidc/token" -H "Content-Type: application/json" -d "$PAYLOAD")
          APPTRUST_ACCESS_TOKEN=$(echo "$RESP" | jq -er '.access_token // empty' || true)
          if [[ -z "$APPTRUST_ACCESS_TOKEN" ]]; then echo "Failed to obtain JFrog access token: $RESP" >&2; exit 1; fi
          echo "APPTRUST_ACCESS_TOKEN=$APPTRUST_ACCESS_TOKEN" >> $GITHUB_ENV

      - name: "[Setup] JFrog CLI"
        # Temporary workaround: using forked action until upstream fix
        # uses: jfrog/setup-jfrog-cli@v4
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: bookverse-recommendations-github
          disable-job-summary: true
          oidc-audience: ${{ vars.JFROG_URL }}

      - name: "[Resolve] App & version"
        run: |
          set -euo pipefail
          SERVICE_NAME=recommendations
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          TARGET_STAGE=${{ inputs.target_stage }}
          APP_VERSION_INPUT="${{ inputs.application_version }}"
          APP_VERSION=""
          if [ -n "$APP_VERSION_INPUT" ]; then
            APP_VERSION="$APP_VERSION_INPUT"
          else
            echo "üîé Fetching latest application version for $APPLICATION_KEY"
            BASE="${{ vars.JFROG_URL }}"; BASE="${BASE%/}"
            jq_expr='(.results // .data // .items // .versions)[0].version'
            RESP=$(curl -sS -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" -H "Accept: application/json" "$BASE/apptrust/api/v1/applications/$APPLICATION_KEY/versions?order_by=created&limit=1" || true)
            if LATEST_VERSION=$(echo "$RESP" | jq -er "$jq_expr" 2>/dev/null); then APP_VERSION="$LATEST_VERSION"; fi
            if [ -z "$APP_VERSION" ]; then
              echo "‚ùå Could not determine latest application version for $APPLICATION_KEY" >&2
              exit 1
            fi
          fi
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "TARGET_STAGE=$TARGET_STAGE" >> $GITHUB_ENV

      - name: "[Setup] Promotion context"
        run: |
          set -euo pipefail
          # This step resolves lifecycle, establishes CURRENT_STAGE, and prepares
          # variables consumed by promote_lib.sh. See promote_lib.sh header docs
          # for how advance_one_step orchestrates promote vs release.
          # Initialize lifecycle data
          export JFROG_URL="${{ vars.JFROG_URL }}"
          export PROJECT_KEY="${{ vars.PROJECT_KEY }}"
          source .github/scripts/promote_lib.sh
          echo "üì¶ Application: $APPLICATION_KEY"
          echo "üè∑Ô∏è Version: $APP_VERSION"
          fetch_summary
          echo "CURRENT_STAGE_BEFORE=${CURRENT_STAGE:-UNASSIGNED}" >> $GITHUB_ENV
          echo "RELEASE_STATUS_BEFORE=${RELEASE_STATUS:-UNKNOWN}" >> $GITHUB_ENV
          LC_FILE=$(mktemp)
          CODE=$(curl -sS -L -o "$LC_FILE" -w "%{http_code}" "$JFROG_URL/access/api/v2/lifecycle/?project_key=$PROJECT_KEY" -H "Authorization: Bearer ${APPTRUST_ACCESS_TOKEN}" -H "Accept: application/json" || echo 000)
          if [[ "$CODE" -lt 200 || "$CODE" -ge 300 ]]; then
            echo "‚ùå Failed to fetch lifecycles list for project '$PROJECT_KEY' (HTTP $CODE)" >&2
            cat "$LC_FILE" || true
            rm -f "$LC_FILE"
            exit 1
          fi
          NORM_FILE=$(mktemp)
          jq -c 'if type=="array" then . elif has("lifecycles") then .lifecycles elif has("items") then .items elif has("results") then .results elif (has("name") and has("stages")) then [.] else [] end' "$LC_FILE" > "$NORM_FILE" 2>/dev/null || printf '[]' > "$NORM_FILE"
          rm -f "$LC_FILE"
          LIFECYCLE_NAME="${LIFECYCLE_NAME:-bookverse-lifecycle}"
          NAMES=$(jq -r --arg n "$LIFECYCLE_NAME" 'map(select(.name == $n)) | .[0].stages // [] | map(if type=="object" then .name else . end) | .[]' "$NORM_FILE" 2>/dev/null || true)
          RELEASE_STAGE=$(jq -r --arg n "$LIFECYCLE_NAME" '([ .[] | select(.name == $n) | .releaseStage ] | .[0]) // empty' "$NORM_FILE" 2>/dev/null || true)
          STAGES=()
          while IFS= read -r orig; do
            [[ -z "$orig" ]] && continue
            display=$(display_stage_for "$orig")
            STAGES+=("$display")
          done < <(printf "%s\n" "$NAMES")
          rm -f "$NORM_FILE"
          if [[ ${#STAGES[@]} -eq 0 ]]; then
            echo "‚ÑπÔ∏è Lifecycle '$LIFECYCLE_NAME' not found; falling back to default stages (DEV ‚Üí QA ‚Üí STAGING ‚Üí PROD)" >&2
            STAGES=(DEV QA STAGING PROD)
          fi
          if [[ -n "$RELEASE_STAGE" ]]; then
            FINAL_STAGE=$(display_stage_for "$RELEASE_STAGE")
          else
            FINAL_STAGE="${STAGES[$((${#STAGES[@]}-1))]}"
          fi
          echo "FINAL_STAGE=$FINAL_STAGE" >> $GITHUB_ENV
          STAGES_STR="${STAGES[*]}"
          echo "STAGES_STR=$STAGES_STR" >> $GITHUB_ENV
          TS_INPUT="${{ inputs.target_stage }}"
          TARGET_NAME="$TS_INPUT"
          if [[ -z "$TARGET_NAME" ]]; then TARGET_NAME="$FINAL_STAGE"; fi
          echo "TARGET_NAME=$TARGET_NAME" >> $GITHUB_ENV
            echo "PROMOTED_STAGES=" >> $GITHUB_ENV
            echo "DID_RELEASE=false" >> $GITHUB_ENV
          PROMO_SUMMARY_FILE=$(mktemp)
          echo "PROMO_SUMMARY_FILE=$PROMO_SUMMARY_FILE" >> $GITHUB_ENV
          {
            echo "### üß≠ Stage-by-stage execution (expected vs actual)"
            echo ""
          } >> "$PROMO_SUMMARY_FILE"

      - name: "[Promote] UNASSIGNED ‚Üí next"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          source .github/scripts/promote_lib.sh
          fetch_summary
          ALLOW_RELEASE=false
          advance_one_step

      - name: "[Promote] Iterate to target (no release)"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          export JFROG_URL='${{ vars.JFROG_URL }}'
          export PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          source .github/scripts/promote_lib.sh
          for i in 1 2 3 4; do
            fetch_summary
            PREV=$(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")
            echo "‚û°Ô∏è Iteration $i begin: stage=$PREV target=$TARGET_NAME final=$FINAL_STAGE stages=[$STAGES_STR]"
            if [[ "$PREV" == "$TARGET_NAME" ]]; then
              echo "Reached target stage ($TARGET_NAME); stopping."
              break
            fi
            ALLOW_RELEASE=false
            advance_one_step
            fetch_summary
            CURR=$(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")
            echo "‚û°Ô∏è Iteration $i result: $PREV -> $CURR"
            if [[ "$CURR" == "$PREV" ]]; then
              echo "No further non-release promotions possible; stopping."
              break
            fi
          done

      - name: "[Evidence] Decide STAGING"
        id: decide-staging
        run: |
          set -euo pipefail
          PS="${PROMOTED_STAGES:-}"; CS="${CURRENT_STAGE:-}"; attach="false"
          if echo " $PS " | grep -q " STAGING "; then attach="true"; fi
          if [[ "$CS" == *"-STAGING" || "$CS" == "STAGING" ]]; then attach="true"; fi
          echo "attach=$attach" >> $GITHUB_OUTPUT

      - name: "[Evidence] Prepare STAGING templates"
        if: ${{ steps.decide-staging.outputs.attach == 'true' }}
        run: |
          set -euo pipefail
          cat > iac-evidence.template.md <<'EOF'
          # Snyk IaC Scan

          **Scan Tool:** Snyk IaC  
          **Scan Date:** ${NOW_TS}  
          **Repository:** ${{ github.repository }}  
          **Commit:** ${{ github.sha }}

          ## Summary
          - Critical: 0
          - High: 1
          - Medium: 2
          - Low: 3

          > Infrastructure-as-Code configuration findings for STAGING gate.
          EOF
          cat > pentest-evidence.template.md <<'EOF'
          # Cobalt.io Pentest Summary

          **Engagement ID:** ${ENG_ID}  
          **Completed:** ${NOW_TS}

          ## Findings
          - Total: 1
          - Critical: 0
          - High: 0
          - Medium: 1
          - Low: 0

          > External penetration test summary attached for STAGING gate.
          EOF
          cat > change-approval.template.md <<'EOF'
          # ServiceNow Change Approval

          **Change ID:** ${CHG_ID}  
          **Status:** Approved  
          **Approved By:** ${APPROVER}  
          **Approved At:** ${NOW_TS}

          > Managerial approval for release promotion from STAGING to PROD.
          EOF

      - name: "[Evidence] Attach STAGING"
        if: ${{ steps.decide-staging.outputs.attach == 'true' }}
        run: |
          set -euo pipefail
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          export NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          export ENG_ID="ENG-$(( (${GITHUB_RUN_NUMBER:-0} + ${GITHUB_RUN_ATTEMPT:-0}) % 9000 + 1000 ))"
          export CHG_ID="CHG-$(( (${GITHUB_RUN_NUMBER:-0} * 10 + ${GITHUB_RUN_ATTEMPT:-0}) ))"
          export APPROVER="user-${GITHUB_ACTOR}-${GITHUB_RUN_ATTEMPT:-1}"

          cat > iac-evidence.json <<JSON
          {"iacScan": {"tool": "Snyk", "scanDate": "${NOW_TS}", "summary": { "critical": 0, "high": 1, "medium": 2, "low": 3 }, "repository": "${{ github.repository }}", "commit": "${{ github.sha }}"}}
          JSON
          envsubst < iac-evidence.template.md > iac-evidence.md
          jf evd create-evidence --predicate iac-evidence.json --markdown iac-evidence.md --predicate-type "https://snyk.io/evidence/iac/v1" --release-bundle "$APPLICATION_KEY" --release-bundle-version "$APP_VERSION" --project "${{ vars.PROJECT_KEY }}" --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}" || echo "‚ö†Ô∏è IaC evidence attachment failed"

          cat > pentest-evidence.json <<JSON
          {"pentest": {"provider": "Cobalt.io", "engagementId": "${ENG_ID}", "completedAt": "${NOW_TS}", "summary": { "totalFindings": 1, "critical": 0, "high": 0, "medium": 1, "low": 0 }}}
          JSON
          envsubst < pentest-evidence.template.md > pentest-evidence.md
          jf evd create-evidence --predicate pentest-evidence.json --markdown pentest-evidence.md --predicate-type "https://cobalt.io/evidence/pentest/v1" --release-bundle "$APPLICATION_KEY" --release-bundle-version "$APP_VERSION" --project "${{ vars.PROJECT_KEY }}" --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}" || echo "‚ö†Ô∏è Pentest evidence attachment failed"

          cat > change-approval.json <<JSON
          {"changeRequest": {"id": "${CHG_ID}", "status": "approved", "approvedBy": "${APPROVER}", "approvedAt": "${NOW_TS}", "environment": "STAGING"}}
          JSON
          envsubst < change-approval.template.md > change-approval.md
          jf evd create-evidence --predicate change-approval.json --markdown change-approval.md --predicate-type "https://servicenow.com/evidence/change-req/v1" --release-bundle "$APPLICATION_KEY" --release-bundle-version "$APP_VERSION" --project "${{ vars.PROJECT_KEY }}" --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" --key-alias "${{ vars.EVIDENCE_KEY_ALIAS }}" || echo "‚ö†Ô∏è Change approval evidence attachment failed"

      - name: "[Release] PROD"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          set -euo pipefail
          export JFROG_URL="${{ vars.JFROG_URL }}"; export PROJECT_KEY="${{ vars.PROJECT_KEY }}"; source .github/scripts/promote_lib.sh
          fetch_summary
          if [[ "$(display_stage_for "${CURRENT_STAGE:-}")" == "STAGING" ]]; then
            ALLOW_RELEASE=true
            advance_one_step
          else
            echo "Skipping release: current stage is $(display_stage_for "${CURRENT_STAGE:-UNASSIGNED}")"
          fi

      - name: "[Tags] Enforce PROD 'latest' invariants"
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          APP_KEY="$APPLICATION_KEY"
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          TOKEN="$APPTRUST_ACCESS_TOKEN"
          RESP=$(mktemp)
          code=$(curl -sS -L -o "$RESP" -w "%{http_code}" \
            "$BASE/applications/$APP_KEY/versions?limit=1000&order_by=created&order_asc=false" \
            -H "Authorization: Bearer $TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$code" -lt 200 || "$code" -ge 300 ]]; then
            echo "‚ùå Failed to list versions (HTTP $code)" >&2; cat "$RESP" || true; exit 1
          fi
          DESIRED=$(jq -r '[.versions[] | select((.release_status|tostring|ascii_upcase)=="RELEASED" or (.release_status|tostring|ascii_upcase)=="TRUSTED_RELEASE") | .version] | unique | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort_by(split(".")|map(tonumber)) | last // empty' "$RESP")
          if [[ -z "$DESIRED" ]]; then
            mapfile -t PREV_LATEST < <(jq -r '.versions[] | select(.tag=="latest") | .version' "$RESP")
            for pv in "${PREV_LATEST[@]:-}"; do
              [ -z "$pv" ] && continue
              restore=$(jq -r --arg v "$pv" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
              printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
              curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$pv" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
            done
            rm -f "$RESP" body.json
            exit 0
          fi
          CURR_TAG=$(jq -r --arg v "$DESIRED" '.versions[] | select(.version==$v) | (.tag // "")' "$RESP")
          jq -n --arg ct "$CURR_TAG" '{tag:"latest", properties:{original_tag_before_latest:[$ct]}}' > body.json
          curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$DESIRED" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          mapfile -t OTHERS < <(jq -r --arg v "$DESIRED" '.versions[] | select(.tag=="latest" and .version!=$v) | .version' "$RESP")
          for ov in "${OTHERS[@]:-}"; do
            [ -z "$ov" ] && continue
            restore=$(jq -r --arg v "$ov" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
            printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
            curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$ov" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          done
          rm -f "$RESP" body.json || true

      - name: "[Summary] Promotion"
        run: |
          echo "## üöÄ AppTrust Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìÑ Evidence Plan: see bookverse-demo-init/docs/EVIDENCE_PLAN.md" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application:** $APPLICATION_KEY" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $APP_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Started at:** ${CURRENT_STAGE_BEFORE}" >> $GITHUB_STEP_SUMMARY
          echo "**Promoted stages:** ${PROMOTED_STAGES:-none}" >> $GITHUB_STEP_SUMMARY
          echo "**Released to ${FINAL_STAGE}:** ${DID_RELEASE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Lifecycle final stage: ${FINAL_STAGE}" >> $GITHUB_STEP_SUMMARY

